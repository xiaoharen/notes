# Easy

## 1 两数之和

哈希表

## 20 有效的括号

栈

## 21 合并两个有序列表

双指针

## 70 爬楼梯

每次只能爬一个台阶或2个台阶,若爬n个台阶,有几种方法?

动态规划:
F(n) = F(n - 1) + F(n - 2)

## 94 二叉树的中序遍历

递归

## 101 对称二叉树

递归

## 104 二叉树的最大深度

递归

## 121 买股票的最佳时机

动态规划

## 136 只出现一次的数字

时间:n	不使用额外空间

异或运算

数组中的每个数都进行异或运算:n1^n2^n3^.....	最后的结果就为只出现一次的数

## 141 环形链表

快慢指针

环形链表说明没用节点指向null,可以以此来判断是否为环形链表
快慢指针在环形链表中始终会相等,以此来结束循环

## 160 相交链表

声明两个指针,一个遍历A+B,一个遍历B+A;若A和B两个链表有重复部分,两指针会相等

## 169 多数元素

投票算法

## 206 反转链表

## 226 反转二叉树

递归

迭代

## 234 回文链表

时间O(n) 	空间O(1)

翻转后半部分链表后,比较前半部分和后半部分

## 283 移动零

双指针

## 338 比特位计算

如何计算每个数中1的个数?

&		按位与
x = x & (x - 1);      每次运算后都会去掉x的最后一个1

## 448 找到所有数组中消失的数字

原地操作:

>用数组下标来记录所有数字

## 461 汉明距离

## 543 二叉树的直径

## 617 合并二叉树

递归操作两个二叉树

# Medium

## 2 两数相加

## 3 无重复字符的最长子串

滑动窗口

## 5 最长回文子串

中心扩散

## 11 盛水最多的容器

## 15 三数之和

排序+双指针

## 17 电话号码的字母组合

回溯

## 19 删除链表的倒数第 N 个结点

前后指针:
设题需移除倒数第n个节点: 让前指针先走n个节点,然后前后指针同时走,当前指针走到null时,后指针所在位置为倒数第n个节点的前一个位置

## 22 括号生成

回溯

## 31 下一个排列

这个要分析具体问题,然后找规律了

## 33 搜索旋转排序数组

题目的难点在于时间复杂度要求O(logn)---->二分

## 34 在排序数组中查找元素的第一个和最后一个位置

二分

## 39 组合总和

回溯+剪枝

## 46 全排列

回溯

## 48 旋转图像

用翻转代替旋转(翻转-->交换)

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        // 水平翻转
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < n; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - i - 1][j];
                matrix[n - i - 1][j] = temp;
            }
        }
        // 主对角线翻转
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
}
```

注意代码中的主对角线翻转是怎么实现的(n x n的矩阵)

```java
// 主对角线翻转
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
```



## 49 字母异位词分组

排序+哈希表



## 53 最大之数组和

动态规划



## 55 跳跃游戏

贪心



## 56 合并区间

数理思维

按左区间升序排序,排序后能合并的区间必是连续的
所以遍历:

> 判断当前区间的左区间是否比集合中最后一个区间的右区间小,若小则比较当前区间的右区间与集合中最后一个区间的右区间,较大则替换原来的右区间;若大则说明前面的区间合并完毕,添加该区间到集合中开始合并下一段区间.

## 62 不同路径

动态规划

## 64 最小路径和

动态规划



## 75 颜色分类

双指针